from main import generate_timeline
from unittest.mock import Mock
import unittest
from flask import jsonify


class TestFunction(unittest.TestCase):
    def test_generate_timeline_on_valid_and_existing_email(self):
        # NOTE: This test assumes graph_api test data exists in the database.
        # This test suite does not create its own data at the moment and is entirely reliant on data generated by graph_api microservice.
        email = 'john.snow@winteriscoming.wes'
        data = {'email': email}
        req = Mock(get_json=Mock(return_value=data), args=data)

        # NOTE: this data is hardcoded. Every time graph_api tests are rerun modified and uuid fields change.
        # One solution is hardcoding them in the dummy data scripts, which is not a problem.
        post_b = {"content": "Post B Content", "modified": "2020-03-10T15:23:33.020296000Z",
                  "uuid": "6566d860-d71f-4258-a222-7bb013086620"}
        post_a = {"content": "Post A Content", "modified": "2020-03-10T15:23:33.020296000Z",
                  "uuid": "791a95b0-77f9-4ccb-940f-04cec294b05e"}

        response = generate_timeline(req)
        self.assertEqual(len(response), 1)
        results = response['results']
        self.assertEqual(len(results), 2)
        self.assertIn(post_b, results)
        self.assertIn(post_a, results)

    def test_generate_timeline_on_non_existing_email(self):
        email = 'does.not@exist.com'
        data = {'email': email}
        req = Mock(get_json=Mock(return_value=data), args=data)

        expected_data = "404 USER NOT FOUND"
        self.assertEqual(generate_timeline(req), expected_data)

    def test_generate_timeline_on_invalid_email(self):
        email = 'invalid'
        data = {'email': email}
        req = Mock(get_json=Mock(return_value=data), args=data)

        expected_data = "422 INVALID EMAIL"
        self.assertEqual(generate_timeline(req), expected_data)

# TODO: test 500s


if __name__ == "__main__":
    unittest.main()
